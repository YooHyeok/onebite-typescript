/* 
# 타입 추론
타입스크립트는 점진적 타입 시스템을 채택하고 있는 언어이다.
점진적 타입 시스템 이란 `let a: number = 10;` 과 같이 변수의 타입을 정의할 수 있는 문법을 제공하여 프로그램이 실행되기 전에 타입 검사를 수행하지만 
만약 `let b = 10;` 과 같이 변수의 타입이 정의되어 있지 않을 때에도 단순히 변수만 선언하고 초기값 할당만 하면 알아서 타입스크립트가 이 초기값을 기준으로 변수의 타입을 추론하는 편리한 타입시스템을 말한다.  
결론적으로 타입스크립트는 자동으로 변수의 타입을 추론한다.
지금까지는 타입스크립트를 배워보는 시간이었기 때문에 대부분의 변수에 직접 타입을 정의해주었지만 앞으로는 타입 추론을 잘 이용하면 굳이 타입을 일일이 변수에 정의하지 않아도 되므로 타이핑 할 양이 줄어들기 때문에 
코드도 간결해지고 생산성도 올라가게 될것이다.
*/
let a:number = 10;
let b = 10;
/* 
다만 한가지 주의할 점은 타입스크립트라고 해도 모든 상황에 타입을 추론해주지많은 않는다.  
예를들어 아래 func함수와 같이 매개변수가 있는 함수를 선언했을 때 매개변수의 type을 직접 정의해 주지 않으면 타입스크립트가 추론할 수 없기 때문에 오류가 발생할 수 있다.
*/
function func(param) {} // Parameter 'param' implicitly has an 'any' type.ts(7006)

/* 
## 타입 추론 상황 및 타입 추론 원리
대표적인 타입 추론이 가능한 상황은 일반적인 변수를 선언하는 상황이다.  
앞서 변수 b를 선언하고 초기값으로 number타입의 값 10을 할당할 경우 자동으로 변수의 타입을 number 타입으로 추론한다.  
커서를 올려보게 될 경우 `let b: number`를 출력한다.  
아래와 같이 변수 c를 선언한 뒤 타입을 지정하지 않고 바로 문자열 값을 할당할 경우에도 마찬가지로 `let c: string`를 출력한다.  
이렇게 타입 스크립트는 일반적으로 변수를 선언하고 초기화하는 상황에서 알아서 자동으로 타입을 잘 추론한다.  
이때 타입스크립트가 타입을 추론하는 기준은 변수의 초기값이다.  
초기값을 기준으로 변수의 타입을 추론하기 때문에 변수 d와 같이 복잡한 객체를 저장하더라도 마우스 커서를 올릴 경우 잘 추론된것을 확인할 수 있다.
 */
let c = "hello"
const d = {
  id: 1,
  username: "유재혁",
  profile: {
    nickname: "유혁스쿨"
  },
  url: ["https://github.com/yooHyeok"]
}
/* 
### 구조분해 할당
예를들어 변수 d로부터 id, username, profile 프로퍼티들을 구조분해 할 때에도 커서를 올려보면 변수의 타입을 자동으로 잘 추론하는 것을 볼 수 있다.  
따라서 id는 number username은 string profile은 nickname 프로퍼티를 가진 객체로 잘 추론이 되는것을 볼 수 있다.  
마찬가지로 배열에 대한 구조분해 할당을 한다고 해도 각각의 원소는 처음 선언한 대상 배열에 맞춰 타입추론이 된다.  
(구조 분해 할당은 새로운 변수를 만들고 값을 복사하여 저장하는 참조 원리)
이렇게 객체와 배열에 대한 구조분해 할당을 포함하여 왠만한 변수 선언은 거의 다 자동으로 추론한다고 보면 된다.  
*/
let {id, username, profile} = d;
let [one, two, three] = [1, "hello", true]

/* 
### 함수 - 매개변수, 반환타입
func1 함수와 같이 선언 후 마우스 커서를 올려보면 함수의 반환 타입도 자동으로 추론하는걸 확인할 수 있다.  
함수의 반환 타입을 추론할 때는 초기화하는 값이 아니라 return문 다음에 오는 반환값을 기준으로 추론한다 라고 이해하면 된다.  
또한 함수의 매개변수에 기본값이 문자열로 할당되어 있다면 `(parameter) msg: string`와 같이 기본값을 기준으로 타입을 추론한다.  

타입 추론 관련 모든 상황들을 암기할 필요는 없다.  
코드를 보고 어떤 변수와 타입을 추론할 정보가 있으면 추론이 되고, 만약 추론할 정보가 없다면 추론이 안된다고 이해하면 된다.  
예를들어 변수 a와 같이 선언 후 초기화 값으로 숫자 10을 할당하면 누가봐도 number타입으로 추론되는게 당연하다.  
마찬가지로 문자열이나 객체도 배열도 구조분해 할당도 함수의 반환타입도 기본값이 설정된 매개변수의 값도 똑같은 원리이다.  
개발자가 코드를 육안으로 살펴보았을 때 어떤 타입으로 추론될것인지 예측 가능할 경우 타입스크립트도 당연히 추론을 할 수 있다.
*/
function func1(msg = "hello") {
  return "hello";
}

/* 
### any타입의 진화
초기값을 생략하여 변수를 선언할 경우 추론 가능한 정보가 없기 때문에 any타입으로 추론된다.  
그렇기 때문에 아무 값이나 할당할 수 있게 된다.  
만약 숫자 값을 할당하게 되면, 할당한 라인의 다음 라인에서 nummber타입으로 추론이 된다.  
number 타입에서만 사용할 수 있는 toFixed같은 메소드도 사용할 수 있으며, string타입의 toUpperCase() 같은 메소드를 호출할 경우 number타입이기 때문에 안된다는 오류를 출력한다.  
신기한것은 e라는 변수에 문자열 값을 할당할 경우 문제가 되지 않는다.  
이렇게 다른 타입의 값으로 다시 할당하고 나면 할당한 다음 라인에서는 또 타입이 string으로 변경된다.  
더 신기한 것은 13을 할당한 다음 라인에 다시 마우스 커서를 올릴 경우 number 타입으로 추론되는것을 확인할 수 있다.  
이렇게 타입이 마치 변신하듯 계속 바뀌는 상황을 any타입의 진화라고 부른다.  

변수를 선언하고 초기값을 지정하지 않으면 암묵적인 any타입으로 추론된다.  
암묵적 any타입이란 타입어노테이션으로 any타입을 지정하지 않더라도 변수의 타입에 대한 아무런 정보가 없을 경우 암묵적으로 any로 추론되는것을 말한다.  
이 경우 변수에 들어가는 값에 따라 any타입이 계속 진화를 하게 된다.  
아래 예시코드에서 주석으로 작성한 1번 라인에서 number타입에 값 할당을 완료할때 까지 any타입이였다가,  
실제 할당 작업이 종료된 순간 number타입으로 진화하는 것이다.  
따라서 2번 라인부터 number타입이 되는것이다.
또 3번 라인에서 "hello"라는 string 타입의 문자열 값을 할당할 경우 할당을 완료할때 까지는 any타입이였다가,  
실제 할당 작업이 죵료된 순간인 4번 라인부터 string 타입으로 진화하는 것이다.  
따라서 `let e` 와 같이 초기값 없이 변수를 선언하기만 하면 암묵적으로 any타입으로 추론이 되며, 이렇게 암묵적으로 추론된 타입은 실제 값 할당시 진화하게 된다.  

암묵적으로 any타입으로 추론되는 것은 `let f:any;` 처럼 명시적으로 any타입을 정의하는 것과는 동작이 다르다.  
명시적으로 any타입을 정의하면 모든 라인이 다 any타입이 되기 때문이다.  
따라서 특정 타입만 사용 가능한 메소드 들을 어디서든 다 호출할 수 있게 된다.  
하지만 암묵적 any 타입을 갖게 만들면 타입이 계속 진화하게 된다.
*/
let e;
e = 13; // 1. let e: any - number 값 할당
e; // 2. let e: number
e.toFixed();
e.toUpperCase();
e = "hello"; // 3. let e: any - string 값 할당
e; // let e: string
e.toUpperCase();
e.toFixed();

let f: any;
f = 13; // 1. let f: any - number 값 할당
f; // 2. let f: any
f.toFixed();
f.toUpperCase();
f = "hello"; // 3. let f: any - string 값 할당
f; // let f: any
f.toUpperCase();
f.toFixed();

/* 
이러한 암묵적 any타입의 경우 중간에 실수로 타입이 잘못 진화될 수도 있고, 내가 아닌 타인이 작성한 코드일 경우 현재 변수의 타입을 알아맞춰야 하는 상황이 발생할 수도 있다.  
따라서 왠만하면 암묵적 any로 변수의 타입을 추론하도록 하는것은 추천하지 않으며, 초기값을 지정하지 않으면 변수의 타입을 위와같이 진화할 수 있다 정도만 알아두면된다.  
*/


/* 
### const 상수와 literal타입
`const num = 10;` 코드를 작성할 경우 커서를 올려보면 let 키워드에서 number타입으로 추론되던것과는 다르게 `const num: 10`와 같이 number 리터럴 타입으로 추론된다.  
const로 선언한 num이라는 변수는 상수이기 때문에 10이라는 값을 할당한 순간 해당 값 외에 다른 값으로 초기화 할 수 없기 때문이다.  
숫자가 아닌 문자열로 선언된 상수 `const str = "hello"`를 선언하더라도 `const str: "hello"`와 같이 string 리터럴 타입으로 추론된다.  
*/
const num = 10;
const str = "hello"

/* 
### 배열 유니온 타입
여러가지 타입 요소를 갖는 배열을 선언하게 되면 유니온 타입을 갖는 배열타입으로 추론이 된다.  
아래 코드의 경우 1이라는 값의 타입과 "string"이라는 값의 타입도 만족해야 되기 때문에 nubmer타입과 string타입 모두 해당되는 union타입으로 자동으로 추론해준다.  
이와같이 초기값을 다양한 타입들을 갖는 배열의 경우 타입스크립트가 모든 배열 요소들의 타입을 비교하여 최적의 공통 타입으로 타입추론 해준다.  
*/

let arr = [1, "string"] // let arr: (string | number)[]


/* 
## 타입 추론 원리 - 타입 넓히기
아래와 같이 변수 g를 선언한 뒤 number 타입 값을 할당하게 되면 const로 선언한 상수와는 다르게 조금 더 범용적인 타입인 number 타입으로 추론해준다.  
이후 변수 g에 999 혹은 -2 등을 할당할 수 있도록 범용적으로 number 타입의 값이라면 다 할당할 수 있도록 추론을 해준다.
const 키워드를 사용한 상수와 같이 number 리터럴 타입으로만 추론하는 것이 아닌 개발자가 해당 변수를 범용적으로 사용할 수 있도록 조금 더 넓은 타입으로 추론해 주는 타입 추론 과정을 타입 넓히기 라고 표현한다.  
*/
let g = 10; 

/* 
결론적으로 타입스크립트는 왠만한 변수는 모두 다 타입을 자동으로 추론하고, const로 선언한 상수가 아닐 경우 범용적으로 해당 변수를 사용할 수 있도록 타입 넓히기를 통해 타입을 잘 추론해준다.
*/