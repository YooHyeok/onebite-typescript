/* 
# 함수 타입 표현식과 호출 시그니처
*/

/* 
## 함수 타입 표현식
함수를 정의하려면 매개변수 타입들과 반환값의 타입들을 정의해서 함수의 타입을 정의할 수 있다.
함수 타입 표현식이라는 것을 이용하면 타입 별칭을 이용해서도 함수의 타입을 정의할 수 있다.
*/
const addA = (a, b) => a + b
const addB = (a: number, b: number): number => a + b;

/* 
## 함수 타입 표현식 예제 
아래와 같이 타입 별칭을 이용하여 매개변수 타입과 반환값 타입 모두 number로 정의한다.  
변수의 타입을 정의하듯 화살표 함수의 함수명 옆에 타입 어노테이션을 적용한다.  
함수의 선언식에 직접 정의해주지 않아도 깔끔하게 함수의 타입 정의가 가능해진다.  
이렇게 타입 별칭을 이용해 함수의 타입을 별도로 정의하는 문법을 함수타입표현식 이라고 하며, 영어로는 Function Type Expression이라고 부른다.  
*/
type Add = (a: number, b: number) => number;
const addC: Add = (a, b) => a + b; 

/* 
인터넷에 돌아다니는 여러 문서나 강의들을 보면 해당 문법을 호출 시그니처 또는 함수 시그니처라고 부르기도 하는데, 엄밀히 말하면 TypeScript 공식 문서에서는 이 문법의 이름을 함수 타입 표현식이라고 소개하고 있다.  
따라서 정확한 이름을 알아두는 건 매우 중요하므로 이렇게 함수 타입 표현식으로 알아두면 된다.  
*/
/* 
## 함수 타입 표현식 장점
덧셈 뿐만 아니라 뺄셈 그리고 곱셈, 나눗셈 등 사칙연산 함수와 비슷한 셩식의 함수 여러개를 만들어야 될 때 일반적으로 매개변수와 반환값에 모두 타입을 일일이 정의해줘야 한다면 중복되는 코드가 너무 많아진다.  
그래서 이럴 때 함수 타입 표현식을 이용하면 굉장히 깔끔하게 코드를 고칠 수 있다.  
type으로 정의된 Add 타입을 Operation 타입에 재정의하여 각 화살표 함수에 타입어노테이션으로 지정해준다.  
*/
type OperationA= Add

const sub: OperationA = (a, b) => a - b;
const multiply: OperationA = (a, b) => a * b;
const divide: OperationA = (a, b) => a * b;


/* 
Operaiont이 아닌 실제 정의된 우항의 타입 자체를 그대로 타입어노테이션으로 적용도 가능하다.
타입별칭은 사실 우항에 있는 타입을 좌항의 이름으로 부르겠다는것으로 Operation이나 Add는 우항에 정의한 함수 타입 입을 해당 이름의 타입으로 저장한것과 같은것이다.  
따라서 굳이 타입별칭을 이용하지 않아도 타입 어노테이션을 바로 정의한 뒤 값에 타입에 맞는 함수를 작성하면 되는것이다.  
*/
const clacA: (a: number, b: number) => number = (a, b) => a + b;

/* 
추가로 당연히 타입의 정의가 두개의 매개변수가 있는 함수를 정의하고 있기 때문에 만약 마음대로 매개변수의 개수를 하나 더 추가하면 당연히 오류가 발생하게 된다.  
타입에는 두개의 매개변수가 있도록 했는데, 실제 구현부에서 3개의 매개변수를 썼기 때문이다.  
따라서 함수의 타입을 표현식으로 정의할 때는 매개변수의 갯수와 타입을 다 맞춰줘야 한다.  
*/
const clacB: (a: number, b: number) => number = (a, b, c) => a + b; // Type '(a: any, b: any, c: any) => any' is not assignable to type '(a: number, b: number) => number'. Target signature provides too few arguments. Expected 3 or more, but got 2.ts(2322)


/* 
## 호출 시그니처 (콜 시그니처)  
함수의 타입을 별도로 정의하는 또 다른 문법이다.  
함수의 타입을 분리해서 정의할 수 있다.  
type을 정의하듯 중괄호를 열어준 뒤, 중괄호 내부에 소괄호를열고 매개변수와 매개변수의 타입, 반환타입을 작성한다.
이렇게 함수 타입을 정의하는 문법을 호출 시그니처라고 부른다.  
*/
type OperationB = {
  (a: number, b: number): number;
}

const add2: OperationB = (a, b) => a + b;
const sub2: OperationB = (a, b) => a - b;
const multiply2: OperationB = (a, b) => a * b;
const divide2: OperationB = (a, b) => a * b;


/* 
일반적으로 함수의 타입을 타입별칭등을 이용하지 않고 정의할 때는 `function func(a: number): void {}` 이렇게 정의하는데
여기서 `(a: number): void` 이 부분만 선언된 타입의 중괄호블록 내부에 작성한것이다.  
이 문법을 호출 시그니처 또는 콜 시그니처라고 부르며, 함수 타입 표현식과 동일한 기능을 한다고 이해하면 된다.  
함수의 타입을 정의하는데 이렇게 중괄호를 열어 마치 객체 타입을 정의하듯 하는 이유는 사실 자바스크립트의 함수도 객체이기 때문이다.  
*/

/* 
참고로 하이브리드 타입이라고 해서 호출 시그니처를 이용할 때 객체 프로퍼티를 추가로 정의할 수 있다.
이것이 가능한 이유는 방금 말했듯 자바스크립트에서는 함수도 객체이기 때문이다.  
OperationC 타입을 갖는 변수 add2는 함수처럼 호출될 수도 있고, .표기법을 이용하여 마치 객체를 사용하듯 사용할 수 있다.  
따라서 이런식으로 타입을 만들면 해당 타입을 갖는 변수를 마치 객체로도 쓰고 함수로도 쓸 수 있다고 해서 하이브리드 타입이라고도 부른다.
*/


type OperationC = {
  (a: number, b: number): number;
  name: string
}