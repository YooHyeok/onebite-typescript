/* 
## 제네릭 인터페이스와 제네릭 타입 별칭
제네릭은 함수 말고도 인터페이스나 타입별칭 그리고 클래스에도 사용이 가능하다.  
*/

/* 
### 제네릭 인터페이스

#### 예제1_1 - 제네릭 타입 인터페이스 정의
제네릭 인터페이스 또한 제네릭 함수처럼 타입 변수를 이용한다.  
예를들어 KeyPair 를 저장하는 객체 타입을 인터페이스로 만들어보자.  
인터페이스를 선언한 후 인터페이스 이름 뒤에 꺽쇠를 열고 타입 변수를 쓰면 된다.  
타입 변수는 K와 V 2개로 구성한다.  
중괄호 안에 key와 value 프로퍼티를 정의하고, 타입변수로 각각의 타입을 정의해준다.
*/
interface IKeyPair <K, V> {
  key: K;
  value: V;
}
/* 
#### 예제1_2 - 제네릭 타입 인터페이스 변수 타입적용1
다음으로 IKeyPair 인터페이스 타입을 갖는 변수를 선언한다.
그런데 이때, 객체 값을 할당할 경우 중괄호를 열자마자 오류가 발생한다.  
*/
let keyPair: IKeyPair = {} // [Error] Generic type 'IKeyPair<K, V>' requires 2 type argument(s).ts(2314)
/* 
IKeyPair<K,V> 제네릭 형식의 두가지 타입의 인수가 필요하다는 내용의 오류이다.
제네릭 인터페이스는 제네릭 함수와는 달리 타입으로 어떤 변수로 정의할때 `반드시 꺽쇠를 열고 타입 변수에 타입을 직접 할당`해줘야 한다.   
타입 변수 K에는 string 타입, 타입 변수 V에는 number를 할당해 주도록 한다.  
제네릭 타입 변수에 타입을 할당한 뒤 중괄호 안에 프로퍼티를 실제로 정의해준다.
*/
let keyPairB: IKeyPair<string, number> = {
  key: "key",
  value: 0
}
/* 
참고로 타입 변수는 사람에 따라서 `타입 파라미터`, `제네릭 타입 변수`, `제네릭 타입 파라미터` 등으로 불린다.  
타입스크립트 공식 문서에는 타입 변수 라고 되어있다.
*/

/* 
#### 예제1_2 - 제네릭 타입 인터페이스 변수 타입적용2
K에는 booleanm V에는 string[] 타입을 정의하여 변수를 하나 더만들어본다.
해당 변수에 할당되는 객체에는 key프로퍼티에 true, value 프로퍼티에는 ['1']과 같이 문자열 배열 값이 들어올 수 있다.  
*/
let keyPairC: IKeyPair<boolean, string[]> = {
  key: true,
  value: ['1']
}
/* 
이렇게 제네릭 인터페이스는 하나의 인터페이스로 다양한 타입의 객체를 표현할 수 있다.
*/
